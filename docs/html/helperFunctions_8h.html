<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ERTbot: include/helperFunctions.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ERTbot
   </div>
   <div id="projectbrief">Bot used to automate and enhance certain processes at the EPFL Rocket Team</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">helperFunctions.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="helperFunctions_8h__dep__incl.png" border="0" usemap="#ainclude_2helperFunctions_8hdep" alt=""/></div>
</div>
</div>
<p><a href="helperFunctions_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aec7b4994021c554c1761ea31d016b680"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#aec7b4994021c554c1761ea31d016b680">MAX_WORD_LENGTH</a>&#160;&#160;&#160;20</td></tr>
<tr class="separator:aec7b4994021c554c1761ea31d016b680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc74efdd29e34bab649ad665326edfe6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#acc74efdd29e34bab649ad665326edfe6">MAX_WORDS</a>&#160;&#160;&#160;1000</td></tr>
<tr class="separator:acc74efdd29e34bab649ad665326edfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a44da972ad90e851418fd02a91f5eacc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpageList.html">pageList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a44da972ad90e851418fd02a91f5eacc4">addPageToList</a> (<a class="el" href="structpageList.html">pageList</a> **head, char *id, char *title, char *path, char *description, char *content, char *updatedAt, char *createdAt)</td></tr>
<tr class="memdesc:a44da972ad90e851418fd02a91f5eacc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new page to the end of a linked list of pages.  <a href="helperFunctions_8h.html#a44da972ad90e851418fd02a91f5eacc4">More...</a><br /></td></tr>
<tr class="separator:a44da972ad90e851418fd02a91f5eacc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75133cba92dc4ecc1fc744ac20647aa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a75133cba92dc4ecc1fc744ac20647aa0">countSlashes</a> (char *str)</td></tr>
<tr class="memdesc:a75133cba92dc4ecc1fc744ac20647aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Counts the number of '/' characters in a given string.  <a href="helperFunctions_8h.html#a75133cba92dc4ecc1fc744ac20647aa0">More...</a><br /></td></tr>
<tr class="separator:a75133cba92dc4ecc1fc744ac20647aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea27bbb2ecd7ea781a93056412bdc54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#aeea27bbb2ecd7ea781a93056412bdc54">prepend_file</a> (char *source_filename, char *destination_filename)</td></tr>
<tr class="memdesc:aeea27bbb2ecd7ea781a93056412bdc54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepends the contents of one file to another file.  <a href="helperFunctions_8h.html#aeea27bbb2ecd7ea781a93056412bdc54">More...</a><br /></td></tr>
<tr class="separator:aeea27bbb2ecd7ea781a93056412bdc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221ce50313eeae13c051db603399264c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a221ce50313eeae13c051db603399264c">zipFolder</a> (char *folderPath)</td></tr>
<tr class="memdesc:a221ce50313eeae13c051db603399264c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zips a folder into a zip file.  <a href="helperFunctions_8h.html#a221ce50313eeae13c051db603399264c">More...</a><br /></td></tr>
<tr class="separator:a221ce50313eeae13c051db603399264c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7ae134f1c5db170a9504bb6f05494b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a9a7ae134f1c5db170a9504bb6f05494b">createMissingFolders</a> (char *path)</td></tr>
<tr class="memdesc:a9a7ae134f1c5db170a9504bb6f05494b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates any missing directories in the specified path.  <a href="helperFunctions_8h.html#a9a7ae134f1c5db170a9504bb6f05494b">More...</a><br /></td></tr>
<tr class="separator:a9a7ae134f1c5db170a9504bb6f05494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ffffc7307eb52b4c07c8cfa704c76bf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a1ffffc7307eb52b4c07c8cfa704c76bf">currentTime</a> ()</td></tr>
<tr class="memdesc:a1ffffc7307eb52b4c07c8cfa704c76bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current time formatted as ISO 8601.  <a href="helperFunctions_8h.html#a1ffffc7307eb52b4c07c8cfa704c76bf">More...</a><br /></td></tr>
<tr class="separator:a1ffffc7307eb52b4c07c8cfa704c76bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ec840ecd7b13ebd83044f1bdc3f01f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a98ec840ecd7b13ebd83044f1bdc3f01f">compareTimes</a> (char *time1, char *time2)</td></tr>
<tr class="memdesc:a98ec840ecd7b13ebd83044f1bdc3f01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two ISO 8601 formatted timestamps.  <a href="helperFunctions_8h.html#a98ec840ecd7b13ebd83044f1bdc3f01f">More...</a><br /></td></tr>
<tr class="separator:a98ec840ecd7b13ebd83044f1bdc3f01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eca957d4ab0658b8292cba476deb56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a89eca957d4ab0658b8292cba476deb56">replaceStringInWiki</a> (<a class="el" href="structpageList.html">pageList</a> **head, char *oldString, char *newString)</td></tr>
<tr class="memdesc:a89eca957d4ab0658b8292cba476deb56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces occurrences of a string in the content of all pages in a linked list, updates and rerenders the pages on the wiki.  <a href="helperFunctions_8h.html#a89eca957d4ab0658b8292cba476deb56">More...</a><br /></td></tr>
<tr class="separator:a89eca957d4ab0658b8292cba476deb56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab35e65a254084055e889e09b9601b1"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#aeab35e65a254084055e889e09b9601b1">createMapWBS</a> (<a class="el" href="structpageList.html">pageList</a> **paths)</td></tr>
<tr class="memdesc:aeab35e65a254084055e889e09b9601b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a graph of a directory in the Work Break Down format from a list of pages.  <a href="helperFunctions_8h.html#aeab35e65a254084055e889e09b9601b1">More...</a><br /></td></tr>
<tr class="separator:aeab35e65a254084055e889e09b9601b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c946e099c1a2c8a4d4c9c9cf315dbcf"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a2c946e099c1a2c8a4d4c9c9cf315dbcf">createList</a> (char *list, <a class="el" href="structpageList.html">pageList</a> **sectionTitle, <a class="el" href="structpageList.html">pageList</a> *links)</td></tr>
<tr class="memdesc:a2c946e099c1a2c8a4d4c9c9cf315dbcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a formatted list of links for a given section title.  <a href="helperFunctions_8h.html#a2c946e099c1a2c8a4d4c9c9cf315dbcf">More...</a><br /></td></tr>
<tr class="separator:a2c946e099c1a2c8a4d4c9c9cf315dbcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22ecc5b3ca36945c1c27fec7bbc8e11"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#ab22ecc5b3ca36945c1c27fec7bbc8e11">updateList</a> (char *list, <a class="el" href="structpageList.html">pageList</a> *sectionTitle, <a class="el" href="structpageList.html">pageList</a> *links)</td></tr>
<tr class="memdesc:ab22ecc5b3ca36945c1c27fec7bbc8e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a specific section in a Markdown list with new links.  <a href="helperFunctions_8h.html#ab22ecc5b3ca36945c1c27fec7bbc8e11">More...</a><br /></td></tr>
<tr class="separator:ab22ecc5b3ca36945c1c27fec7bbc8e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c2a7bf739adf7ef779757378d53dc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structwikiFlag.html">wikiFlag</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a93c2a7bf739adf7ef779757378d53dc3">parseFlags</a> (char *text, <a class="el" href="structwikiFlag.html">wikiFlag</a> flag)</td></tr>
<tr class="memdesc:a93c2a7bf739adf7ef779757378d53dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a text to extract and link wiki flags based on specific comment markers.  <a href="helperFunctions_8h.html#a93c2a7bf739adf7ef779757378d53dc3">More...</a><br /></td></tr>
<tr class="separator:a93c2a7bf739adf7ef779757378d53dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a6e436c56ee0af7d484b6b9e62f96a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a30a6e436c56ee0af7d484b6b9e62f96a">breakdownCommand</a> (char *sentence, <a class="el" href="structcommand.html">command</a> *cmd)</td></tr>
<tr class="memdesc:a30a6e436c56ee0af7d484b6b9e62f96a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a command sentence into a <code>command</code> structure.  <a href="helperFunctions_8h.html#a30a6e436c56ee0af7d484b6b9e62f96a">More...</a><br /></td></tr>
<tr class="separator:a30a6e436c56ee0af7d484b6b9e62f96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e16055869d95daf977faf3c8da5306c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a0e16055869d95daf977faf3c8da5306c">createLocalGraphMindMap</a> (<a class="el" href="structpageList.html">pageList</a> **tempPage, <a class="el" href="structpageList.html">pageList</a> **incomingPaths, <a class="el" href="structpageList.html">pageList</a> **outgoingPaths)</td></tr>
<tr class="memdesc:a0e16055869d95daf977faf3c8da5306c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a PlantUML mind map representation of a page's "local" graph, which is a graph which shows all of the incoming and outgoing links.  <a href="helperFunctions_8h.html#a0e16055869d95daf977faf3c8da5306c">More...</a><br /></td></tr>
<tr class="separator:a0e16055869d95daf977faf3c8da5306c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad245aaed540cd5e61c3961b1ffa49e11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#ad245aaed540cd5e61c3961b1ffa49e11">freePageList</a> (<a class="el" href="structpageList.html">pageList</a> **head)</td></tr>
<tr class="memdesc:ad245aaed540cd5e61c3961b1ffa49e11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory allocated for a linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> nodes.  <a href="helperFunctions_8h.html#ad245aaed540cd5e61c3961b1ffa49e11">More...</a><br /></td></tr>
<tr class="separator:ad245aaed540cd5e61c3961b1ffa49e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a7405f73301d6689256e6c8a6d39c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a36a7405f73301d6689256e6c8a6d39c5">printAcronymsToFile</a> (char *pathToAccronymList, char *str)</td></tr>
<tr class="memdesc:a36a7405f73301d6689256e6c8a6d39c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds accronyms in a string and appends the accronyms to the path give in argument (void but modifies local accronymList)  <a href="helperFunctions_8h.html#a36a7405f73301d6689256e6c8a6d39c5">More...</a><br /></td></tr>
<tr class="separator:a36a7405f73301d6689256e6c8a6d39c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f05557b087f922bcba706858bec413"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#ad7f05557b087f922bcba706858bec413">sortWords</a> (char words[<a class="el" href="helperFunctions_8h.html#acc74efdd29e34bab649ad665326edfe6">MAX_WORDS</a>][<a class="el" href="helperFunctions_8h.html#aec7b4994021c554c1761ea31d016b680">MAX_WORD_LENGTH</a>], int numWords)</td></tr>
<tr class="memdesc:ad7f05557b087f922bcba706858bec413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts an array of words using the bubble sort algorithm.  <a href="helperFunctions_8h.html#ad7f05557b087f922bcba706858bec413">More...</a><br /></td></tr>
<tr class="separator:ad7f05557b087f922bcba706858bec413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c42fd8447d5f977311fc999875cb8d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a6c42fd8447d5f977311fc999875cb8d9">removeDuplicatesAndSort</a> (char *filename)</td></tr>
<tr class="memdesc:a6c42fd8447d5f977311fc999875cb8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes duplicate words from a file and sorts the remaining words alphabetically.  <a href="helperFunctions_8h.html#a6c42fd8447d5f977311fc999875cb8d9">More...</a><br /></td></tr>
<tr class="separator:a6c42fd8447d5f977311fc999875cb8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f66597db28c66f462c4100d1b962d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpageList.html">pageList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#ac3f66597db28c66f462c4100d1b962d4">findPageLinks</a> (char *content, <a class="el" href="structpageList.html">pageList</a> **links)</td></tr>
<tr class="memdesc:ac3f66597db28c66f462c4100d1b962d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts page links from the given content and adds them to a linked list.  <a href="helperFunctions_8h.html#ac3f66597db28c66f462c4100d1b962d4">More...</a><br /></td></tr>
<tr class="separator:ac3f66597db28c66f462c4100d1b962d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a71f003caa08e9500810391a5b7b35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpageList.html">pageList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a36a71f003caa08e9500810391a5b7b35">findImageLinks</a> (char *input, <a class="el" href="structpageList.html">pageList</a> **head)</td></tr>
<tr class="memdesc:a36a71f003caa08e9500810391a5b7b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts image links from the given input and adds them to a linked list.  <a href="helperFunctions_8h.html#a36a71f003caa08e9500810391a5b7b35">More...</a><br /></td></tr>
<tr class="separator:a36a71f003caa08e9500810391a5b7b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ae174ea2de7edb78dc3cedc3a68c68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#ae4ae174ea2de7edb78dc3cedc3a68c68">filterLinks</a> (<a class="el" href="structpageList.html">pageList</a> **head)</td></tr>
<tr class="memdesc:ae4ae174ea2de7edb78dc3cedc3a68c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filters and cleans up the paths in the linked list of page links. Used to remove sizing and positioning options from images on the wiki.  <a href="helperFunctions_8h.html#ae4ae174ea2de7edb78dc3cedc3a68c68">More...</a><br /></td></tr>
<tr class="separator:ae4ae174ea2de7edb78dc3cedc3a68c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355f498d47a18a3504af0cf2d7c7e263"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a355f498d47a18a3504af0cf2d7c7e263">printPages</a> (<a class="el" href="structpageList.html">pageList</a> **head)</td></tr>
<tr class="memdesc:a355f498d47a18a3504af0cf2d7c7e263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the title and content of each page in the linked list to Slack.  <a href="helperFunctions_8h.html#a355f498d47a18a3504af0cf2d7c7e263">More...</a><br /></td></tr>
<tr class="separator:a355f498d47a18a3504af0cf2d7c7e263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454d6332204217e49e09883692f4b58a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpageList.html">pageList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a454d6332204217e49e09883692f4b58a">findIncomingLinks</a> (<a class="el" href="structpageList.html">pageList</a> **head, char *linkTrackerContent, char *subjectPagePath)</td></tr>
<tr class="memdesc:a454d6332204217e49e09883692f4b58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and adds incoming links to a linked list. The links must reference a specific subject page.  <a href="helperFunctions_8h.html#a454d6332204217e49e09883692f4b58a">More...</a><br /></td></tr>
<tr class="separator:a454d6332204217e49e09883692f4b58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c42033a1aa80af793e090434e47c87f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpageList.html">pageList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a0c42033a1aa80af793e090434e47c87f">findOutgoingLinks</a> (<a class="el" href="structpageList.html">pageList</a> **head, char *linkTrackerContent, char *subjectPagePath)</td></tr>
<tr class="memdesc:a0c42033a1aa80af793e090434e47c87f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds and adds outgoing links to a linked list. The links must be in a specific subject page's content.  <a href="helperFunctions_8h.html#a0c42033a1aa80af793e090434e47c87f">More...</a><br /></td></tr>
<tr class="separator:a0c42033a1aa80af793e090434e47c87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad26cc57130809dce3fcf0b1d1263fbd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#ad26cc57130809dce3fcf0b1d1263fbd8">parseRequirementsList</a> (cJSON *requirementList, char *content)</td></tr>
<tr class="memdesc:ad26cc57130809dce3fcf0b1d1263fbd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a list of requirements from a content string and adds them to a cJSON object (convert from wiki-DRL to cJSON requirements).  <a href="helperFunctions_8h.html#ad26cc57130809dce3fcf0b1d1263fbd8">More...</a><br /></td></tr>
<tr class="separator:ad26cc57130809dce3fcf0b1d1263fbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e26614c1237ac08c991cc4fa4b74805"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a4e26614c1237ac08c991cc4fa4b74805">addRequirementToCjsonObject</a> (cJSON *requirements, char *idStr, char *pathStr, char *nameStr, char *descriptionStr)</td></tr>
<tr class="memdesc:a4e26614c1237ac08c991cc4fa4b74805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a new requirement to a JSON array object.  <a href="helperFunctions_8h.html#a4e26614c1237ac08c991cc4fa4b74805">More...</a><br /></td></tr>
<tr class="separator:a4e26614c1237ac08c991cc4fa4b74805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf4ed7d073ff5c3202f4d0822ce167d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a7bf4ed7d073ff5c3202f4d0822ce167d">parseJSONRequirementListInToArray</a> (cJSON *requirements)</td></tr>
<tr class="memdesc:a7bf4ed7d073ff5c3202f4d0822ce167d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a cJSON array of requirements into a formatted string array.  <a href="helperFunctions_8h.html#a7bf4ed7d073ff5c3202f4d0822ce167d">More...</a><br /></td></tr>
<tr class="separator:a7bf4ed7d073ff5c3202f4d0822ce167d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ca8e6f324434aecbf090cd41a59163"><td class="memItemLeft" align="right" valign="top">cJSON *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a07ca8e6f324434aecbf090cd41a59163">parseArrayIntoJSONRequirementList</a> (char *input_str)</td></tr>
<tr class="memdesc:a07ca8e6f324434aecbf090cd41a59163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a JSON string representing an array of requirements into a structured cJSON object.  <a href="helperFunctions_8h.html#a07ca8e6f324434aecbf090cd41a59163">More...</a><br /></td></tr>
<tr class="separator:a07ca8e6f324434aecbf090cd41a59163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fc294868fc0e95b23164a1ee428317"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#aa6fc294868fc0e95b23164a1ee428317">buildDrlFromJSONRequirementList</a> (cJSON *requirementList)</td></tr>
<tr class="memdesc:aa6fc294868fc0e95b23164a1ee428317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a DRL (Design Requirements List) string from a JSON object containing requirements.  <a href="helperFunctions_8h.html#aa6fc294868fc0e95b23164a1ee428317">More...</a><br /></td></tr>
<tr class="separator:aa6fc294868fc0e95b23164a1ee428317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b1c193c80a93e4915bcdcf4d8a5703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpageList.html">pageList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a73b1c193c80a93e4915bcdcf4d8a5703">buildRequirementPageFromJSONRequirementList</a> (cJSON *requirementList, char *requirementId)</td></tr>
<tr class="memdesc:a73b1c193c80a93e4915bcdcf4d8a5703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> entry from a JSON object containing requirements for a specific requirement ID. Each page's content is a requirement page.  <a href="helperFunctions_8h.html#a73b1c193c80a93e4915bcdcf4d8a5703">More...</a><br /></td></tr>
<tr class="separator:a73b1c193c80a93e4915bcdcf4d8a5703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495c84b774eac6ff8508809480966d4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a495c84b774eac6ff8508809480966d4b">appendMentionedIn</a> (<a class="el" href="structpageList.html">pageList</a> **head)</td></tr>
<tr class="memdesc:a495c84b774eac6ff8508809480966d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a section listing pages that mention the current page.  <a href="helperFunctions_8h.html#a495c84b774eac6ff8508809480966d4b">More...</a><br /></td></tr>
<tr class="separator:a495c84b774eac6ff8508809480966d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c108828f7a25b69f42cd1a878f1be8c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#a0c108828f7a25b69f42cd1a878f1be8c">createVcdPieChart</a> (char *unverifiedPopulation, char *partiallyVerifiedPopulation, char *verifiedPopulation)</td></tr>
<tr class="memdesc:a0c108828f7a25b69f42cd1a878f1be8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Vega chart configuration for a pie chart depicting verification statuses.  <a href="helperFunctions_8h.html#a0c108828f7a25b69f42cd1a878f1be8c">More...</a><br /></td></tr>
<tr class="separator:a0c108828f7a25b69f42cd1a878f1be8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa850683b717490b317de665a81bfc3e2"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="helperFunctions_8h.html#aa850683b717490b317de665a81bfc3e2">updateVcdStackedAreaChart</a> (char *json_str, char *week, int verifiedValue, int partiallyVerifiedValue, int unverifiedValue)</td></tr>
<tr class="memdesc:aa850683b717490b317de665a81bfc3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates a JSON string representing a stacked area chart with new weekly data.  <a href="helperFunctions_8h.html#aa850683b717490b317de665a81bfc3e2">More...</a><br /></td></tr>
<tr class="separator:aa850683b717490b317de665a81bfc3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aec7b4994021c554c1761ea31d016b680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7b4994021c554c1761ea31d016b680">&#9670;&nbsp;</a></span>MAX_WORD_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_WORD_LENGTH&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc74efdd29e34bab649ad665326edfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc74efdd29e34bab649ad665326edfe6">&#9670;&nbsp;</a></span>MAX_WORDS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_WORDS&#160;&#160;&#160;1000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a44da972ad90e851418fd02a91f5eacc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44da972ad90e851418fd02a91f5eacc4">&#9670;&nbsp;</a></span>addPageToList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpageList.html">pageList</a>* addPageToList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>updatedAt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>createdAt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new page to the end of a linked list of pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">head</td><td>Pointer to the pointer of the <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure, representing the head of the linked list of pages. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The unique identifier for the page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">title</td><td>The title of the page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The path of the page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">description</td><td>A description of the page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">content</td><td>The content of the page. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">updatedAt</td><td>The timestamp of when the page was last updated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">createdAt</td><td>The timestamp of when the page was created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the head of the updated <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> with the new page added.</dd></dl>
<p>This function allocates memory for a new <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> node, copies the provided page details into the new node, and appends it to the end of the linked list. If the list is empty, the new node becomes the head of the list.</p>
<dl class="section note"><dt>Note</dt><dd>Ensure that the provided strings (<code>id</code>, <code>title</code>, <code>path</code>, <code>description</code>, <code>content</code>, <code>updatedAt</code>, <code>createdAt</code>) are valid and properly formatted. Memory allocated for the new node's strings should be freed when the node is no longer needed to prevent memory leaks. </dd></dl>

</div>
</div>
<a id="a4e26614c1237ac08c991cc4fa4b74805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e26614c1237ac08c991cc4fa4b74805">&#9670;&nbsp;</a></span>addRequirementToCjsonObject()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void addRequirementToCjsonObject </td>
          <td>(</td>
          <td class="paramtype">cJSON *&#160;</td>
          <td class="paramname"><em>requirements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>idStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pathStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>nameStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>descriptionStr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a new requirement to a JSON array object. </p>
<p>This function creates a new JSON object representing a requirement and adds it to the provided JSON array. The requirement object includes fields for id, path, name, and description, each of which is initialized with the corresponding string values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requirements</td><td>A pointer to the <code>cJSON</code> array where the new requirement object will be added. </td></tr>
    <tr><td class="paramname">idStr</td><td>The string representing the ID of the requirement. </td></tr>
    <tr><td class="paramname">pathStr</td><td>The string representing the path of the requirement. </td></tr>
    <tr><td class="paramname">nameStr</td><td>The string representing the name of the requirement. </td></tr>
    <tr><td class="paramname">descriptionStr</td><td>The string representing the description of the requirement.</td></tr>
  </table>
  </dd>
</dl>
<p>The function performs the following steps:</p><ul>
<li>Creates a new JSON object for the requirement.</li>
<li>Creates JSON strings for the <code>id</code>, <code>path</code>, <code>name</code>, and <code>description</code> fields.</li>
<li>Adds these fields to the requirement object.</li>
<li>Adds the requirement object to the provided <code>requirements</code> JSON array. </li>
</ul>

</div>
</div>
<a id="a495c84b774eac6ff8508809480966d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495c84b774eac6ff8508809480966d4b">&#9670;&nbsp;</a></span>appendMentionedIn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void appendMentionedIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends a section listing pages that mention the current page. </p>
<p>This function updates the content of the given <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> to include a section that lists all pages that mention the current page. The function finds incoming links from a link tracker page, formats them as a markdown list, and appends them to the current page's content. Special characters in the content are escaped before the page is updated and rendered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to a pointer to a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure representing the current page. The content of this page will be updated to include a list of pages that mention it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This function does not return a value.</dd></dl>
<ul>
<li>The function first initializes a <code>linkTrackerPage</code> and retrieves its content.</li>
<li>It then uses this content to find incoming links related to the current page by calling <code>findIncomingLinks</code>.</li>
<li>The section titled "Mentioned in" is appended to the current page's content.</li>
<li>For each incoming link, a markdown list item is added to the content, linking to the page that mentions the current page.</li>
<li>After processing all incoming links, the content is updated with a links-list class identifier.</li>
<li>Special characters in the content (newline and quotation marks) are escaped using <code>replaceWord</code>.</li>
<li>Finally, the updated page content is saved using <code>updatePageContentMutation</code>, and the page is rendered using <code>renderMutation</code>. </li>
</ul>

</div>
</div>
<a id="a30a6e436c56ee0af7d484b6b9e62f96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a6e436c56ee0af7d484b6b9e62f96a">&#9670;&nbsp;</a></span>breakdownCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void breakdownCommand </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sentence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcommand.html">command</a> *&#160;</td>
          <td class="paramname"><em>cmd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a command sentence into a <code>command</code> structure. </p>
<p>This function takes a sentence and breaks it down into individual words, then stores these words into the fields of a <code>command</code> structure. The sentence is expected to contain a function name followed by up to nine arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sentence</td><td>The input string containing the command sentence to be parsed. </td></tr>
    <tr><td class="paramname">cmd</td><td>A pointer to a <code>command</code> structure where the parsed command and arguments will be stored.</td></tr>
  </table>
  </dd>
</dl>
<p>The function creates a copy of the input sentence to avoid modifying the original string. It then tokenizes the sentence using spaces as delimiters and stores each token in the appropriate field of the <code>command</code> structure. It handles up to ten words (one function and nine arguments). If the sentence contains more than ten words, an error message is printed. All allocated strings in the <code>command</code> structure are dynamically allocated and should be freed by the caller when no longer needed.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>MAX_ARGUMENTS</code> constant should define the maximum number of arguments allowed (including the function name). The <code>command</code> structure should have fields for storing the function and up to nine arguments. </dd></dl>

</div>
</div>
<a id="aa6fc294868fc0e95b23164a1ee428317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fc294868fc0e95b23164a1ee428317">&#9670;&nbsp;</a></span>buildDrlFromJSONRequirementList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* buildDrlFromJSONRequirementList </td>
          <td>(</td>
          <td class="paramtype">cJSON *&#160;</td>
          <td class="paramname"><em>requirementList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a DRL (Design Requirements List) string from a JSON object containing requirements. </p>
<p>This function constructs a DRL string by iterating over a JSON array of requirement objects. Each requirement object is expected to contain specific fields such as "ID", "Path", "Title", and "Description". The resulting DRL string is built by appending formatted information from each requirement to a template DRL string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requirementList</td><td>A <code>cJSON</code> object containing an array of requirement objects under the "requirements" key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dynamically allocated string containing the formatted DRL. The caller is responsible for freeing this memory. If the input JSON is not properly formatted or if memory allocation fails, the function may return an incorrect or partially filled string.</dd></dl>
<ul>
<li>The function first retrieves the "requirements" array from the <code>requirementList</code> object.</li>
<li>It initializes the DRL string using a predefined template.</li>
<li>For each requirement object in the array, it extracts the fields "ID", "Path", "Title", and "Description".</li>
<li>These fields are appended to the DRL string in a specific format, including separators and markers.</li>
<li>After processing all requirements, the function appends "{.links-list}" to the end of the DRL string.</li>
<li>If any errors are encountered (e.g., missing "requirements" array or incorrect object format), appropriate error messages are printed.</li>
<li>The function returns the final DRL string. </li>
</ul>

</div>
</div>
<a id="a73b1c193c80a93e4915bcdcf4d8a5703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b1c193c80a93e4915bcdcf4d8a5703">&#9670;&nbsp;</a></span>buildRequirementPageFromJSONRequirementList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpageList.html">pageList</a>* buildRequirementPageFromJSONRequirementList </td>
          <td>(</td>
          <td class="paramtype">cJSON *&#160;</td>
          <td class="paramname"><em>requirementList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>requirementId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> entry from a JSON object containing requirements for a specific requirement ID. Each page's content is a requirement page. </p>
<p>This function generates a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> entry by extracting details for a specific requirement from a JSON object. It constructs a page content string using a template and appends information such as ID, Title, Description, Source, Author, Justification, Compliance, Criticality, and Verification details. The page content is formatted in a specific markdown-like structure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requirementList</td><td>A <code>cJSON</code> object containing an array of requirement objects under the "requirements" key. </td></tr>
    <tr><td class="paramname">requirementId</td><td>A string representing the ID of the requirement to be processed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure containing the generated page. If no requirement with the specified ID is found or if an error occurs, the function may return <code>NULL</code>.</dd></dl>
<ul>
<li>The function first retrieves the "requirements" array from the <code>requirementList</code> object.</li>
<li>It initializes the page content using a predefined template.</li>
<li>For each requirement object in the array, it extracts fields including "ID", "Title", "Description", "Source", "Author", "Justification", "Criticality", "Compliance", and "Verification" details.</li>
<li>If the ID matches the <code>requirementId</code> parameter, the page content is updated with formatted information from the requirement.</li>
<li>Sections are added to the page content based on the presence and values of the fields:<ul>
<li><b>Title</b>: Displays the requirement ID and title.</li>
<li><b>Description</b>: Displays the description of the requirement.</li>
<li><b>Information Box</b>: Shows additional information such as Source, Author, and Assignee, if they are not empty.</li>
<li><b>Justification</b>: Adds justification if available.</li>
<li><b>Compliance</b>: Shows the compliance status with corresponding icons.</li>
<li><b>Criticality</b>: Shows the criticality level with corresponding icons.</li>
<li><b>Verification</b>: Adds verification details for multiple reviews and verification methods, including status and deadlines.</li>
</ul>
</li>
<li>After processing, the page content is added to the <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure and the list is returned.</li>
<li><p class="startli">If any errors are encountered (e.g., missing "requirements" array or incorrect object format), appropriate error messages are printed.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Function is too long it needs to be broken up into smaller functions. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a98ec840ecd7b13ebd83044f1bdc3f01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ec840ecd7b13ebd83044f1bdc3f01f">&#9670;&nbsp;</a></span>compareTimes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compareTimes </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>time1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>time2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two ISO 8601 formatted timestamps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time1</td><td>A string representing the first timestamp in ISO 8601 format (e.g., "YYYY-MM-DDTHH:MM:SS"). </td></tr>
    <tr><td class="paramname">time2</td><td>A string representing the second timestamp in ISO 8601 format (e.g., "YYYY-MM-DDTHH:MM:SS").</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int Returns -1 if <code>time1</code> is earlier than <code>time2</code>, 1 if <code>time1</code> is later than <code>time2</code>, and 0 if both timestamps are equal.</dd></dl>
<p>This function parses the provided ISO 8601 formatted strings into <code>struct tm</code> structures, converts these structures to <code>time_t</code> values using <code>mktime</code>, and then compares the resulting <code>time_t</code> values. It assumes the timestamps are in UTC and formatted correctly. The function adjusts year and month values to match the <code>struct tm</code> representation requirements. </p>

</div>
</div>
<a id="a75133cba92dc4ecc1fc744ac20647aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75133cba92dc4ecc1fc744ac20647aa0">&#9670;&nbsp;</a></span>countSlashes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int countSlashes </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Counts the number of '/' characters in a given string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The input string to be analyzed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The number of '/' characters found in the string.</dd></dl>
<p>This function iterates through the provided string and counts the occurrences of the '/' character. It returns the total count.</p>
<dl class="section note"><dt>Note</dt><dd>The input string must be a valid null-terminated string. Ensure that the input string is not NULL to avoid undefined behavior. </dd></dl>

</div>
</div>
<a id="a2c946e099c1a2c8a4d4c9c9cf315dbcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c946e099c1a2c8a4d4c9c9cf315dbcf">&#9670;&nbsp;</a></span>createList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* createList </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>sectionTitle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> *&#160;</td>
          <td class="paramname"><em>links</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a formatted list of links for a given section title. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The initial string to which the list will be appended. </td></tr>
    <tr><td class="paramname">sectionTitle</td><td>Pointer to a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure containing the section title and path. </td></tr>
    <tr><td class="paramname">links</td><td>Pointer to a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure representing a list of links to be included under the section.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dynamically allocated string containing the formatted list.</dd></dl>
<p>This function generates a formatted list in Markdown style, starting with a section header based on the <code>sectionTitle</code> and followed by a list of links. It appends the section title as a link to the section's path, then adds each link from the <code>links</code> list, each on a new line. The resulting string is dynamically allocated and should be freed by the caller when no longer needed.</p>
<p>The function uses <code>appendStrings</code> to concatenate strings. After building the list, it calls <code>freePageList</code> to free the memory allocated for the <code>links</code> list. </p>

</div>
</div>
<a id="a0e16055869d95daf977faf3c8da5306c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e16055869d95daf977faf3c8da5306c">&#9670;&nbsp;</a></span>createLocalGraphMindMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* createLocalGraphMindMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>tempPage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>incomingPaths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>outgoingPaths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a PlantUML mind map representation of a page's "local" graph, which is a graph which shows all of the incoming and outgoing links. </p>
<p>This function generates a PlantUML mind map diagram for a given page. It includes the page itself, along with its incoming and outgoing links. The diagram is formatted using PlantUML syntax and includes links with associated titles and paths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tempPage</td><td>A pointer to a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure representing the central page for which the mind map is created. </td></tr>
    <tr><td class="paramname">incomingPaths</td><td>A pointer to a linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structures representing the pages that link to the central page. </td></tr>
    <tr><td class="paramname">outgoingPaths</td><td>A pointer to a linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structures representing the pages linked from the central page.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dynamically allocated string containing the PlantUML mind map diagram.</dd></dl>
<p>The function constructs the PlantUML mind map starting with the central page, then iterates through the incoming and outgoing link lists to add corresponding entries. The mind map uses "+" for the central node, "--" for incoming links, and "++" for outgoing links. Each link is represented with its path and title. The function also handles memory cleanup for the incoming and outgoing link lists after generating the diagram.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>rewrite with new cJSON structured link tracker </dd></dl>

</div>
</div>
<a id="aeab35e65a254084055e889e09b9601b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab35e65a254084055e889e09b9601b1">&#9670;&nbsp;</a></span>createMapWBS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* createMapWBS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a graph of a directory in the Work Break Down format from a list of pages. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paths</td><td>Pointer to the head of the linked list of pages.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dynamically allocated string containing the WBS map in PlantUML format.</dd></dl>
<p>This function generates a WBS map in PlantUML format from a linked list of pages. It traverses the list of pages, calculates the depth of each page based on its path, and builds a hierarchical WBS structure. The WBS structure is represented using asterisks (<code>*</code>) to indicate levels of hierarchy. For each page, it adds an entry to the WBS with a hyperlink to the page and its title. The function handles cases where pages are not directly related to each other by adding parent folders and adjusting the depth accordingly. The resulting map is enclosed in PlantUML syntax for rendering.</p>
<p>The function uses <code>countSlashes</code> to determine the depth of each page, <code>getDirPath</code> to find parent directories, and <code>getDocId</code> to extract the document ID from the path. It uses <code>appendStrings</code> to build the final map string. The output string is dynamically allocated and should be freed by the caller when no longer needed. </p>

</div>
</div>
<a id="a9a7ae134f1c5db170a9504bb6f05494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7ae134f1c5db170a9504bb6f05494b">&#9670;&nbsp;</a></span>createMissingFolders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void createMissingFolders </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates any missing directories in the specified path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">path</td><td>The full path of directories to create. The function will create directories as needed, including any intermediate directories that do not exist.</td></tr>
  </table>
  </dd>
</dl>
<p>This function processes the given path, creating directories one by one. It starts from the root of the path and works its way down, creating each directory in turn if it does not already exist. The path is tokenized by '/' to handle each directory level. It uses the <code>mkdir</code> function to create directories and checks for existing directories with <code>stat</code>. If an error occurs while creating a directory, the function prints an error message and stops.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the path is a valid string and that the application has the necessary permissions to create directories in the specified location. The <code>mkdir</code> function is used with mode <code>0755</code>, which sets the directory permissions to readable and executable by everyone and writable by the owner. </dd></dl>

</div>
</div>
<a id="a0c108828f7a25b69f42cd1a878f1be8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c108828f7a25b69f42cd1a878f1be8c">&#9670;&nbsp;</a></span>createVcdPieChart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* createVcdPieChart </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>unverifiedPopulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>partiallyVerifiedPopulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>verifiedPopulation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Vega chart configuration for a pie chart depicting verification statuses. </p>
<p>This function generates a Vega chart specification for a pie chart that visualizes the distribution of three categories: unverified, partially verified, and verified populations. The chart is formatted using Vega's schema and is designed to be displayed with the <code>kroki</code> tool.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unverifiedPopulation</td><td>A string representing the population of unverified items. This value is inserted into the Vega chart configuration. </td></tr>
    <tr><td class="paramname">partiallyVerifiedPopulation</td><td>A string representing the population of partially verified items. This value is inserted into the Vega chart configuration. </td></tr>
    <tr><td class="paramname">verifiedPopulation</td><td>A string representing the population of verified items. This value is inserted into the Vega chart configuration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dynamically allocated string containing the Vega chart specification. The returned string includes the provided population values substituted into the template.</dd></dl>
<ul>
<li>The function starts with a predefined Vega chart template in string format.</li>
<li>It replaces placeholder values (<code>DefaultUnverifiedPopulation</code>, <code>DefaultPartiallyVerifiedPopulation</code>, <code>DefaultVerifiedPopulation</code>) in the template with the provided arguments.</li>
<li>The final Vega chart specification is returned, ready to be used for rendering a pie chart. </li>
</ul>

</div>
</div>
<a id="a1ffffc7307eb52b4c07c8cfa704c76bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ffffc7307eb52b4c07c8cfa704c76bf">&#9670;&nbsp;</a></span>currentTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* currentTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current time formatted as ISO 8601. </p>
<dl class="section return"><dt>Returns</dt><dd>char* A string containing the current time in ISO 8601 format (UTC). The format is "YYYY-MM-DDTHH:MM:SS.000Z".</dd></dl>
<p>This function obtains the current UTC time and formats it into an ISO 8601 string representation. The formatted time is printed to the standard output. The function uses <code>strftime</code> to format the time according to the ISO 8601 standard, and it returns a static buffer containing the formatted time. </p>

</div>
</div>
<a id="ae4ae174ea2de7edb78dc3cedc3a68c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ae174ea2de7edb78dc3cedc3a68c68">&#9670;&nbsp;</a></span>filterLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void filterLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filters and cleans up the paths in the linked list of page links. Used to remove sizing and positioning options from images on the wiki. </p>
<p>This function iterates through each <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> node in the linked list and processes the <code>path</code> field. It removes any characters that appear after the first space in the path, effectively cleaning up the paths to ensure they do not contain unwanted trailing information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to a pointer to the head of the linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structures. The function modifies the <code>path</code> field of each node in the list.</td></tr>
  </table>
  </dd>
</dl>
<p>The function performs the following steps:</p><ul>
<li>Iterates through each node in the linked list.</li>
<li>Calls <code>removeAfterSpace</code> on the <code>path</code> field of each node to remove any characters after the first space.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Used for wiki to pdf conversion </dd></dl>

</div>
</div>
<a id="a36a71f003caa08e9500810391a5b7b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a71f003caa08e9500810391a5b7b35">&#9670;&nbsp;</a></span>findImageLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpageList.html">pageList</a>* findImageLinks </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts image links from the given input and adds them to a linked list. </p>
<p>This function scans the provided text input to find all image links formatted as <code>![alt_text](link)</code>. It extracts the link for each found image link, allocates memory for it, and adds it to a linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The text content from which image links are to be extracted. The content should contain links in the format <code>![alt_text](link)</code>. </td></tr>
    <tr><td class="paramname">head</td><td>A pointer to a pointer to a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure. This is used to build the linked list of found image links.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structures containing the extracted image links.</dd></dl>
<p>The function performs the following steps:</p><ul>
<li>Searches for image link patterns using delimiters <code>![</code> and <code>](</code>.</li>
<li>Extracts the link from each image link and allocates memory for it.</li>
<li>Adds the extracted link to the linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structures.</li>
<li>Handles potential memory allocation errors by freeing previously allocated memory and calling <code>freePageList</code>. </li>
</ul>

</div>
</div>
<a id="a454d6332204217e49e09883692f4b58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454d6332204217e49e09883692f4b58a">&#9670;&nbsp;</a></span>findIncomingLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpageList.html">pageList</a>* findIncomingLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>linkTrackerContent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>subjectPagePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds and adds incoming links to a linked list. The links must reference a specific subject page. </p>
<p>This function searches through the provided content for sections that reference links. It extracts titles and paths from these sections and adds them to the <code>incomingLinks</code> list if they match the <code>subjectPagePath</code>. The function operates on a copy of the content to avoid modifying the original content.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to a pointer to the head of the linked list where the incoming links will be added. </td></tr>
    <tr><td class="paramname">linkTrackerContent</td><td>A string containing the content to be searched for incoming links. </td></tr>
    <tr><td class="paramname">subjectPagePath</td><td>The path of the subject page being searched for in the content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated list of incoming links, which includes any newly found links that reference the <code>subjectPagePath</code>.</dd></dl>
<p>The function performs the following steps:</p><ul>
<li>Creates a copy of the <code>linkTrackerContent</code> to process.</li>
<li>Searches for sections in the content that start with "## [".</li>
<li>Extracts titles, paths, and links from these sections.</li>
<li>Compares each link to <code>subjectPagePath</code>. If a match is found, it adds the corresponding title and path to the <code>incomingLinks</code> list.</li>
<li>Updates the pointers to continue searching through the content.</li>
<li>Frees the allocated memory for the content copy before returning.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>replace with a cJSON version </dd></dl>

</div>
</div>
<a id="a0c42033a1aa80af793e090434e47c87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c42033a1aa80af793e090434e47c87f">&#9670;&nbsp;</a></span>findOutgoingLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpageList.html">pageList</a>* findOutgoingLinks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>linkTrackerContent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>subjectPagePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds and adds outgoing links to a linked list. The links must be in a specific subject page's content. </p>
<p>This function searches through the provided content to find sections where the path matches the <code>subjectPagePath</code>. It extracts links from these sections and adds them to the <code>outgoingLinks</code> list. The function processes a copy of the content to avoid modifying the original content.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to a pointer to the head of the linked list where the outgoing links will be added. </td></tr>
    <tr><td class="paramname">linkTrackerContent</td><td>A string containing the content to be searched for outgoing links. </td></tr>
    <tr><td class="paramname">subjectPagePath</td><td>The path of the subject page to be matched in the content.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated list of outgoing links, which includes any newly found links that reference the <code>subjectPagePath</code>.</dd></dl>
<p>The function performs the following steps:</p><ul>
<li>Creates a copy of the <code>linkTrackerContent</code> to process.</li>
<li>Searches for sections in the content that start with "## [".</li>
<li>Extracts titles, paths, and links from these sections.</li>
<li>If the path matches <code>subjectPagePath</code>, it extracts and adds the links found in that section to the <code>outgoingLinks</code> list.</li>
<li>Updates the pointers to continue searching through the content.</li>
<li>Frees the allocated memory for the content copy before returning.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>replace with a cJSON version </dd></dl>

</div>
</div>
<a id="ac3f66597db28c66f462c4100d1b962d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f66597db28c66f462c4100d1b962d4">&#9670;&nbsp;</a></span>findPageLinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpageList.html">pageList</a>* findPageLinks </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>content</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>links</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts page links from the given content and adds them to a linked list. </p>
<p>This function parses the provided content to find all page links formatted as <code>[title](link)</code>. It extracts the title and link for each found page link, allocates memory for them, and adds them to a linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">content</td><td>The text content from which page links are to be extracted. The content should contain links in the format <code>[title](link)</code>. </td></tr>
    <tr><td class="paramname">links</td><td>A pointer to a pointer to a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure. This is used to build the linked list of found page links.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the updated linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structures containing the extracted links and titles.</dd></dl>
<p>The function performs the following steps:</p><ul>
<li>Searches for the start and end of each page link using delimiters <code>](</code> and <code>)</code>.</li>
<li>Extracts the title and link from each page link and allocates memory for them.</li>
<li>Adds the extracted page link and title to the linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structures.</li>
<li>Handles potential memory allocation errors by freeing previously allocated memory and calling <code>freePageList</code>. </li>
</ul>

</div>
</div>
<a id="ad245aaed540cd5e61c3961b1ffa49e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad245aaed540cd5e61c3961b1ffa49e11">&#9670;&nbsp;</a></span>freePageList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void freePageList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees the memory allocated for a linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> nodes. </p>
<p>This function iterates through the linked list starting from the head pointer, freeing all dynamically allocated memory associated with each node, including the memory for the node itself. It ensures that each field of the node is checked for non-NULL before attempting to free the memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to a pointer to the first node of the linked list. The list will be traversed and freed until all nodes are deallocated and the head pointer is set to NULL.</td></tr>
  </table>
  </dd>
</dl>
<p>The function iterates through the linked list, freeing each node's allocated memory in the following order:</p><ul>
<li><code>id</code></li>
<li><code>title</code></li>
<li><code>path</code></li>
<li><code>description</code></li>
<li><code>content</code></li>
<li><code>updatedAt</code></li>
<li><code>createdAt</code></li>
</ul>
<p>After freeing the memory for each field, the node itself is deallocated. Debugging print statements are included to show which memory is being freed, which can be helpful for troubleshooting memory management issues.</p>
<dl class="section note"><dt>Note</dt><dd>The <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure should have fields for dynamically allocated strings. It is important to ensure that this function is called when the list is no longer needed to prevent memory leaks. </dd></dl>

</div>
</div>
<a id="a07ca8e6f324434aecbf090cd41a59163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ca8e6f324434aecbf090cd41a59163">&#9670;&nbsp;</a></span>parseArrayIntoJSONRequirementList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cJSON* parseArrayIntoJSONRequirementList </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input_str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a JSON string representing an array of requirements into a structured cJSON object. </p>
<p>This function converts a JSON string containing an array of requirements into a <code>cJSON</code> object. Each item in the input array is expected to be an array of 35 strings, which are mapped to specific fields in the output JSON object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input_str</td><td>The input JSON string representing the array of requirements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <code>cJSON</code> object containing the requirements. If there is an error in parsing or creating the JSON structure, the function returns <code>NULL</code>.</dd></dl>
<ul>
<li>The function parses the input string to extract a JSON array named "values".</li>
<li>Each element of this "values" array should be an array of exactly 35 strings.</li>
<li>The function creates a new JSON object with a single field "requirements" which is a JSON array.</li>
<li>For each requirement in the input array, a JSON object is created with fields corresponding to specific columns (e.g., ID, Title, Description, etc.).</li>
<li>These fields are added to the "requirements" array in the output JSON object.</li>
<li>If the input format is incorrect or memory allocation fails, the function prints an error message and returns <code>NULL</code>. </li>
</ul>

</div>
</div>
<a id="a93c2a7bf739adf7ef779757378d53dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c2a7bf739adf7ef779757378d53dc3">&#9670;&nbsp;</a></span>parseFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwikiFlag.html">wikiFlag</a>* parseFlags </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structwikiFlag.html">wikiFlag</a>&#160;</td>
          <td class="paramname"><em>flag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a text to extract and link wiki flags based on specific comment markers. </p>
<p>This function scans the provided text for comments marked with "&lt;!--" and "--&gt;". It extracts command information from these comments and creates a linked list of <code><a class="el" href="structwikiFlag.html" title="Represents a flag in the wiki system that contains a command, pointers, and a link to the next flag.">wikiFlag</a></code> structures. The <code><a class="el" href="structwikiFlag.html" title="Represents a flag in the wiki system that contains a command, pointers, and a link to the next flag.">wikiFlag</a></code> structures are populated with pointers to the extracted text segments and associated commands.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The input text to be parsed for wiki flags. </td></tr>
    <tr><td class="paramname">flag</td><td>A <code><a class="el" href="structwikiFlag.html" title="Represents a flag in the wiki system that contains a command, pointers, and a link to the next flag.">wikiFlag</a></code> structure used as a template for new flag entries. It is not modified but serves as a base for memory allocation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the head of a linked list of <code><a class="el" href="structwikiFlag.html" title="Represents a flag in the wiki system that contains a command, pointers, and a link to the next flag.">wikiFlag</a></code> structures. Each node in the list contains extracted command information and text pointers.</dd></dl>
<p>The function iterates through the text looking for comment markers. It extracts text between "&lt;!--" and "--&gt;" markers, creates a <code><a class="el" href="structwikiFlag.html" title="Represents a flag in the wiki system that contains a command, pointers, and a link to the next flag.">wikiFlag</a></code> structure for each pair of markers, and links these structures in a list. Odd-numbered flags are associated with pointers starting from the end of the comment, while even-numbered flags are associated with pointers starting from the beginning of the comment. The function handles multiple pairs of markers and continues parsing until the end of the text is reached. </p>

</div>
</div>
<a id="a7bf4ed7d073ff5c3202f4d0822ce167d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bf4ed7d073ff5c3202f4d0822ce167d">&#9670;&nbsp;</a></span>parseJSONRequirementListInToArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* parseJSONRequirementListInToArray </td>
          <td>(</td>
          <td class="paramtype">cJSON *&#160;</td>
          <td class="paramname"><em>requirements</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a cJSON array of requirements into a formatted string array. </p>
<p>This function takes a <code>cJSON</code> array of requirements and generates a JSON-formatted string that represents the array. Each requirement in the <code>cJSON</code> array is formatted as a list of strings, including the ID, path, name, and description. The resulting string is formatted as a JSON array of arrays.</p>
<p>The function performs the following steps:</p><ul>
<li>Calculates the required buffer size for the output string based on the number of requirements and their individual lengths.</li>
<li>Allocates memory for the output string with the calculated buffer size.</li>
<li>Iterates through each requirement in the <code>cJSON</code> array, extracts the ID, path, name, and description, and appends them to the output string in a JSON array format.</li>
<li>Returns the resulting formatted string.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requirements</td><td>A pointer to the <code>cJSON</code> array containing the requirements to be converted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a dynamically allocated string containing the JSON-formatted requirements. Returns NULL if memory allocation fails. </dd></dl>

</div>
</div>
<a id="ad26cc57130809dce3fcf0b1d1263fbd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad26cc57130809dce3fcf0b1d1263fbd8">&#9670;&nbsp;</a></span>parseRequirementsList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void parseRequirementsList </td>
          <td>(</td>
          <td class="paramtype">cJSON *&#160;</td>
          <td class="paramname"><em>requirementList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>content</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a list of requirements from a content string and adds them to a cJSON object (convert from wiki-DRL to cJSON requirements). </p>
<p>This function extracts requirement details from the given <code>content</code> string, where each requirement is formatted in a specific manner. It parses each requirement's ID, path, name, and description, and adds these details to the provided <code>requirements</code> cJSON array.</p>
<p>The content string is expected to contain requirements formatted with the following flags:</p><ul>
<li>ID: Begins with "\\n- ["</li>
<li>Path: Follows "](/"</li>
<li>Name: Follows ") **"</li>
<li>Description: Starts with "**\\n" and ends with "\\n"</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requirements</td><td>A pointer to the <code>cJSON</code> array to which parsed requirements will be added. </td></tr>
    <tr><td class="paramname">content</td><td>The string containing the requirements in a specified format.</td></tr>
  </table>
  </dd>
</dl>
<p>The function performs the following steps:</p><ul>
<li>Searches for the start of each requirement section using specific start flags.</li>
<li>Extracts the ID, path, name, and description for each requirement by calculating their lengths.</li>
<li>Allocates memory for the extracted strings and copies them from the content.</li>
<li>Adds the extracted requirement to the <code>requirements</code> cJSON array using the <code>addRequirementToCjsonObject</code> function.</li>
<li>Frees allocated memory for the strings after they are added to the JSON object. </li>
</ul>

</div>
</div>
<a id="aeea27bbb2ecd7ea781a93056412bdc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea27bbb2ecd7ea781a93056412bdc54">&#9670;&nbsp;</a></span>prepend_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void prepend_file </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>source_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>destination_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepends the contents of one file to another file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">source_filename</td><td>The name of the file whose contents are to be prepended. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">destination_filename</td><td>The name of the file to which the contents are prepended.</td></tr>
  </table>
  </dd>
</dl>
<p>This function opens the source file for reading and the destination file for both reading and writing. It reads the contents of the destination file, then writes the contents of the source file to the beginning of the destination file, followed by the original contents of the destination file. The function handles memory allocation for buffering and ensures that all file operations are properly managed.</p>
<dl class="section note"><dt>Note</dt><dd>Ensure that the source and destination filenames are valid and accessible. The destination file is opened in read-write mode, and the source file is opened in read mode. This function does not handle file access errors beyond basic checks. </dd></dl>

</div>
</div>
<a id="a36a7405f73301d6689256e6c8a6d39c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a7405f73301d6689256e6c8a6d39c5">&#9670;&nbsp;</a></span>printAcronymsToFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printAcronymsToFile </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>pathToAccronymList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds accronyms in a string and appends the accronyms to the path give in argument (void but modifies local accronymList) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">pathToAccronymList</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>acronym list should be added to wiki instead of append file </dd></dl>

</div>
</div>
<a id="a355f498d47a18a3504af0cf2d7c7e263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355f498d47a18a3504af0cf2d7c7e263">&#9670;&nbsp;</a></span>printPages()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void printPages </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>head</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the title and content of each page in the linked list to Slack. </p>
<p>This function iterates through the linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> nodes and sends the title and content of each page to Slack using <code>sendMessageToSlack</code>. It also includes formatting to clearly separate each page's information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>A pointer to a pointer to the head of the linked list of <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structures. The function processes each node in the list and sends its title and content to Slack.</td></tr>
  </table>
  </dd>
</dl>
<p>The function performs the following steps:</p><ul>
<li>Iterates through each node in the linked list.</li>
<li>Retrieves the current page using <code>getPage</code> and processes the page's title and content.</li>
<li>Sends the page title and content to Slack using <code>sendMessageToSlack</code>, including appropriate labels and spacing. </li>
</ul>

</div>
</div>
<a id="a6c42fd8447d5f977311fc999875cb8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c42fd8447d5f977311fc999875cb8d9">&#9670;&nbsp;</a></span>removeDuplicatesAndSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void removeDuplicatesAndSort </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes duplicate words from a file and sorts the remaining words alphabetically. </p>
<p>This function reads words from a specified file, removes duplicates, sorts the unique words in alphabetical order, and then writes the sorted unique words back to the file. Each word is expected to be on a new line in the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The path to the file containing the words to be processed. The file should be in a format where each word is on a new line.</td></tr>
  </table>
  </dd>
</dl>
<p>The function performs the following steps:</p><ul>
<li>Opens the file for reading and reads words line by line, storing them in an array.</li>
<li>Removes any newline characters from the words.</li>
<li>Closes the file after reading.</li>
<li>Sorts the words using the <code>sortWords</code> function.</li>
<li>Opens the file for writing and writes the sorted unique words back to the file.</li>
<li>If a word is the same as the previous word, it is not written to avoid duplicates. </li>
</ul>

</div>
</div>
<a id="a89eca957d4ab0658b8292cba476deb56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89eca957d4ab0658b8292cba476deb56">&#9670;&nbsp;</a></span>replaceStringInWiki()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void replaceStringInWiki </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> **&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>oldString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>newString</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces occurrences of a string in the content of all pages in a linked list, updates and rerenders the pages on the wiki. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">head</td><td>Pointer to the head of the linked list of pages. </td></tr>
    <tr><td class="paramname">oldString</td><td>The string to be replaced in the page content. </td></tr>
    <tr><td class="paramname">newString</td><td>The string to replace <code>oldString</code> with.</td></tr>
  </table>
  </dd>
</dl>
<p>This function iterates through each page in the linked list, retrieves the page content using <code>getPage</code>, replaces occurrences of <code>oldString</code> with <code>newString</code>, escapes backslashes and quotes in the content, and updates the page content on the wiki using <code>updatePageContentMutation</code>. It then performs a render mutation for each page to apply the changes using <code>renderMutation</code>. After processing all pages, it frees the memory allocated for the page list using <code>freePageList</code> and sends a message to Slack indicating which pages have been updated. </p>

</div>
</div>
<a id="ad7f05557b087f922bcba706858bec413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f05557b087f922bcba706858bec413">&#9670;&nbsp;</a></span>sortWords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sortWords </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>words</em>[MAX_WORDS][MAX_WORD_LENGTH], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts an array of words using the bubble sort algorithm. </p>
<p>This function sorts an array of strings (words) in ascending lexicographical order using the bubble sort technique. Each word is compared with the next, and if they are out of order, they are swapped. The process is repeated until the entire array is sorted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">words</td><td>An array of strings where each string represents a word to be sorted. The array should be of size <code>MAX_WORDS</code>, and each string should be of length <code>MAX_WORD_LENGTH</code>. </td></tr>
    <tr><td class="paramname">numWords</td><td>The number of words in the <code>words</code> array. This value should be less than or equal to <code>MAX_WORDS</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>The function uses a nested loop structure to implement bubble sort:</p><ul>
<li>The outer loop iterates through each word, while the inner loop compares adjacent words and swaps them if needed.</li>
<li>After each pass through the array, the largest unsorted word "bubbles" up to its correct position. </li>
</ul>

</div>
</div>
<a id="ab22ecc5b3ca36945c1c27fec7bbc8e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22ecc5b3ca36945c1c27fec7bbc8e11">&#9670;&nbsp;</a></span>updateList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* updateList </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> *&#160;</td>
          <td class="paramname"><em>sectionTitle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structpageList.html">pageList</a> *&#160;</td>
          <td class="paramname"><em>links</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a specific section in a Markdown list with new links. </p>
<p>This function updates a section of a Markdown list by replacing an old list with a new one. The section to be updated is identified by a path, and the new list of links is appended to this section.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>The original Markdown list as a string. This string will be modified to include the updated list. </td></tr>
    <tr><td class="paramname">sectionTitle</td><td>A pointer to a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure representing the section to be updated. The path in this structure is used to identify the section. </td></tr>
    <tr><td class="paramname">links</td><td>A pointer to a <code><a class="el" href="structpageList.html" title="Structure to represent a linked list of pages, each containing metadata and content.">pageList</a></code> structure containing the new list of links to be added under the section.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The updated Markdown list as a dynamically allocated string. The caller is responsible for freeing this memory.</dd></dl>
<p>The function appends the new list of links to the specified section in the original Markdown list. It locates the section in the list using the <code>sectionTitle</code> path and replaces the old list with the new one. If the section or end of the section is not found, it prints an error message and returns the original list. The memory allocated for the new list is freed before returning.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Should be replaced or at least rewritten so that it uses cJSON functions </dd></dl>

</div>
</div>
<a id="aa850683b717490b317de665a81bfc3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa850683b717490b317de665a81bfc3e2">&#9670;&nbsp;</a></span>updateVcdStackedAreaChart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* updateVcdStackedAreaChart </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>json_str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>week</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verifiedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>partiallyVerifiedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unverifiedValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates a JSON string representing a stacked area chart with new weekly data. </p>
<p>This function updates a JSON string that contains data for a stacked area chart by adding new data points for the specified week. The new data points include verified, partially verified, and unverified values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json_str</td><td>A string containing the JSON data of the existing chart. This JSON is expected to have a "data" object with a "values" array where new entries will be added. </td></tr>
    <tr><td class="paramname">week</td><td>A string representing the week for which the data is being added. This value will be included in each new data entry. </td></tr>
    <tr><td class="paramname">verifiedValue</td><td>An integer representing the value for the "Verified" status for the given week. </td></tr>
    <tr><td class="paramname">partiallyVerifiedValue</td><td>An integer representing the value for the "Partially Verified" status for the given week. </td></tr>
    <tr><td class="paramname">unverifiedValue</td><td>An integer representing the value for the "Unverified" status for the given week.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dynamically allocated string containing the updated JSON data, with new data points added to the "values" array. The caller is responsible for freeing this string.</dd></dl>
<ul>
<li>The function parses the input JSON string and retrieves the "values" array from the "data" object.</li>
<li>Three new JSON objects are created, each representing one of the statuses ("Verified", "Partially Verified", "Unverified") with their corresponding values and the specified week.</li>
<li>These new JSON objects are added to the "values" array.</li>
<li>The updated JSON structure is converted back to a string and returned.</li>
<li>If any error occurs during parsing or updating, the function returns <code>NULL</code>. </li>
</ul>

</div>
</div>
<a id="a221ce50313eeae13c051db603399264c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221ce50313eeae13c051db603399264c">&#9670;&nbsp;</a></span>zipFolder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int zipFolder </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>folderPath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Zips a folder into a zip file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">folderPath</td><td>The path to the folder to be zipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0 on success, or 1 if the zip operation fails.</dd></dl>
<p>This function constructs a shell command to zip the specified folder using the <code>zip</code> command-line utility. It changes the directory to the specified folder, creates a zip file with the same name as the folder, and includes all contents of the folder in the zip file. The function uses <code>system()</code> to execute the command and checks the result to determine if the operation was successful.</p>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the <code>zip</code> command-line utility is installed and available in the system's PATH. Error handling is basic, focusing on whether the <code>system()</code> call succeeds or fails. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
